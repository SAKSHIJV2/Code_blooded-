[
  {
    "id": "DSA-SA-001",
    "track": "DSA",
    "topic": "Arrays",
    "subtopic": "Basics",
    "difficulty": "Easy",
    "question_type": "SHORT_ANSWER",
    "question": "Why is accessing an array element by index considered efficient?",
    "ideal_answer": "Because arrays store elements in contiguous memory, allowing direct access using index.",
    "expected_keywords": ["contiguous", "direct access"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Conceptual Clarity"], "weight": 1, "max_time_sec": 90 }
  },
  {
    "id": "DSA-SA-002",
    "track": "DSA",
    "topic": "Arrays",
    "subtopic": "Insertion",
    "difficulty": "Easy",
    "question_type": "SHORT_ANSWER",
    "question": "Why is insertion at the beginning of an array costly?",
    "ideal_answer": "Because all existing elements must be shifted to make space.",
    "expected_keywords": ["shift", "elements"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Time Complexity"], "weight": 1, "max_time_sec": 90 }
  },
  {
    "id": "DSA-SA-003",
    "track": "DSA",
    "topic": "Searching",
    "subtopic": "Binary Search",
    "difficulty": "Easy",
    "question_type": "SHORT_ANSWER",
    "question": "Why must data be sorted before applying binary search?",
    "ideal_answer": "Binary search relies on ordering to eliminate half the search space.",
    "expected_keywords": ["sorted", "halve"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Searching"], "weight": 1, "max_time_sec": 90 }
  },
  {
    "id": "DSA-SA-004",
    "track": "DSA",
    "topic": "Sorting",
    "subtopic": "Bubble Sort",
    "difficulty": "Easy",
    "question_type": "SHORT_ANSWER",
    "question": "Why is bubble sort inefficient for large datasets?",
    "ideal_answer": "It repeatedly compares adjacent elements, leading to quadratic time complexity.",
    "expected_keywords": ["O(n^2)", "adjacent"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Sorting"], "weight": 1, "max_time_sec": 90 }
  },
  {
    "id": "DSA-SA-005",
    "track": "DSA",
    "topic": "Recursion",
    "subtopic": "Base Case",
    "difficulty": "Easy",
    "question_type": "SHORT_ANSWER",
    "question": "What happens if a recursive function has no base condition?",
    "ideal_answer": "It results in infinite recursion and eventually causes stack overflow.",
    "expected_keywords": ["infinite", "stack overflow"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Recursion"], "weight": 1, "max_time_sec": 90 }
  },

  {
    "id": "DSA-SA-006",
    "track": "DSA",
    "topic": "Stack",
    "subtopic": "Concept",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why are stacks suitable for undo/redo operations?",
    "ideal_answer": "Because they follow LIFO, allowing reversal of recent actions.",
    "expected_keywords": ["LIFO", "undo"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Stack"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-007",
    "track": "DSA",
    "topic": "Queue",
    "subtopic": "Applications",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why are queues used in CPU scheduling?",
    "ideal_answer": "Because processes are handled in the order they arrive (FIFO).",
    "expected_keywords": ["FIFO", "scheduling"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Queue"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-008",
    "track": "DSA",
    "topic": "Linked List",
    "subtopic": "Advantages",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why are linked lists better than arrays for frequent insertions?",
    "ideal_answer": "Because insertion does not require shifting elements.",
    "expected_keywords": ["insertion", "no shifting"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Linked List"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-009",
    "track": "DSA",
    "topic": "Trees",
    "subtopic": "Traversal",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why does inorder traversal of a BST give sorted output?",
    "ideal_answer": "Because left subtree contains smaller values and right subtree larger values.",
    "expected_keywords": ["BST", "sorted"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Trees"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-010",
    "track": "DSA",
    "topic": "Graphs",
    "subtopic": "BFS",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why is BFS preferred for shortest path in unweighted graphs?",
    "ideal_answer": "Because BFS explores nodes level by level.",
    "expected_keywords": ["level order", "shortest path"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Graphs"], "weight": 2, "max_time_sec": 120 }
  },

  {
    "id": "DSA-SA-011",
    "track": "DSA",
    "topic": "Graphs",
    "subtopic": "DFS",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why can DFS detect cycles in a graph?",
    "ideal_answer": "Because it keeps track of visited nodes and recursion stack.",
    "expected_keywords": ["cycle", "visited"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Graphs"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-012",
    "track": "DSA",
    "topic": "Heap",
    "subtopic": "Priority Queue",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why are heaps used to implement priority queues?",
    "ideal_answer": "Because heaps allow fast access to highest or lowest priority elements.",
    "expected_keywords": ["heap", "priority"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Heap"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-013",
    "track": "DSA",
    "topic": "Hashing",
    "subtopic": "Collision",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "What causes collisions in hashing?",
    "ideal_answer": "When different keys generate the same hash value.",
    "expected_keywords": ["collision", "hash"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Hashing"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-014",
    "track": "DSA",
    "topic": "Hashing",
    "subtopic": "Load Factor",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why should load factor be controlled in hash tables?",
    "ideal_answer": "To reduce collisions and maintain performance.",
    "expected_keywords": ["load factor", "performance"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Hashing"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-015",
    "track": "DSA",
    "topic": "Sorting",
    "subtopic": "Stability",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "What does it mean for a sorting algorithm to be stable?",
    "ideal_answer": "It preserves the relative order of equal elements.",
    "expected_keywords": ["stable", "relative order"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Sorting"], "weight": 2, "max_time_sec": 120 }
  },

  {
    "id": "DSA-SA-016",
    "track": "DSA",
    "topic": "Complexity",
    "subtopic": "Big-O",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why does Big-O notation ignore constants?",
    "ideal_answer": "Because it focuses on growth rate for large input sizes.",
    "expected_keywords": ["growth rate", "constants"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Complexity"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-017",
    "track": "DSA",
    "topic": "Complexity",
    "subtopic": "Space",
    "difficulty": "Medium",
    "question_type": "SHORT_ANSWER",
    "question": "Why does recursion usually consume more space?",
    "ideal_answer": "Because each recursive call occupies stack memory.",
    "expected_keywords": ["stack", "space"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Complexity"], "weight": 2, "max_time_sec": 120 }
  },
  {
    "id": "DSA-SA-018",
    "track": "DSA",
    "topic": "Arrays",
    "subtopic": "Sliding Window",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "Why is sliding window better than brute force for subarray problems?",
    "ideal_answer": "It avoids repeated calculations by reusing previous results.",
    "expected_keywords": ["optimization", "reuse"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Optimization"], "weight": 3, "max_time_sec": 150 }
  },
  {
    "id": "DSA-SA-019",
    "track": "DSA",
    "topic": "Arrays",
    "subtopic": "Two Pointer",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "Why does the two-pointer technique reduce time complexity?",
    "ideal_answer": "Because it processes elements in a single pass instead of nested loops.",
    "expected_keywords": ["single pass", "optimization"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Optimization"], "weight": 3, "max_time_sec": 150 }
  },
  {
    "id": "DSA-SA-020",
    "track": "DSA",
    "topic": "Trees",
    "subtopic": "Balanced Tree",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "Why do balanced trees provide better performance?",
    "ideal_answer": "They keep height minimal, ensuring logarithmic operations.",
    "expected_keywords": ["balanced", "logarithmic"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Trees"], "weight": 3, "max_time_sec": 150 }
  },

  {
    "id": "DSA-SA-021",
    "track": "DSA",
    "topic": "Graphs",
    "subtopic": "Representation",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "Why is adjacency list preferred for sparse graphs?",
    "ideal_answer": "Because it uses less memory by storing only existing edges.",
    "expected_keywords": ["sparse", "memory"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Graphs"], "weight": 3, "max_time_sec": 150 }
  },
  {
    "id": "DSA-SA-022",
    "track": "DSA",
    "topic": "Sorting",
    "subtopic": "Quick Sort",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "Why can quick sort perform poorly in worst case?",
    "ideal_answer": "Because of unbalanced partitions.",
    "expected_keywords": ["worst case", "partition"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Sorting"], "weight": 3, "max_time_sec": 150 }
  },
  {
    "id": "DSA-SA-023",
    "track": "DSA",
    "topic": "Hashing",
    "subtopic": "Rehashing",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "Why is rehashing required in hash tables?",
    "ideal_answer": "To maintain performance when load factor becomes high.",
    "expected_keywords": ["rehashing", "load factor"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Hashing"], "weight": 3, "max_time_sec": 150 }
  },
  {
    "id": "DSA-SA-024",
    "track": "DSA",
    "topic": "Complexity",
    "subtopic": "Amortized",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "What is amortized time complexity?",
    "ideal_answer": "Average time per operation over a sequence of operations.",
    "expected_keywords": ["amortized", "average"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Complexity"], "weight": 3, "max_time_sec": 150 }
  },
  {
    "id": "DSA-SA-025",
    "track": "DSA",
    "topic": "Design Thinking",
    "subtopic": "Trade-offs",
    "difficulty": "Hard",
    "question_type": "SHORT_ANSWER",
    "question": "Why is it important to consider time-space trade-offs?",
    "ideal_answer": "Optimizing one often increases the other, so balance is needed.",
    "expected_keywords": ["trade-off", "optimization"],
    "user_explanation_required": false,
    "evaluation": { "skill_dimension": ["Decision Making"], "weight": 3, "max_time_sec": 150 }
  }
]