[
  {
    "id": "DSA-R-001",
    "track": "DSA",
    "topic": "Arrays",
    "subtopic": "Design Choice",
    "difficulty": "Easy",
    "question_type": "REASONING",
    "question": "You need fast access to elements by index. Would you choose an array or linked list? Why?",
    "ideal_answer": "Array, because it provides O(1) index-based access.",
    "expected_keywords": ["array", "index", "O(1)"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Decision Making"], "weight": 1, "max_time_sec": 120 }
  },
  {
    "id": "DSA-R-002",
    "track": "DSA",
    "topic": "Arrays",
    "subtopic": "Optimization",
    "difficulty": "Easy",
    "question_type": "REASONING",
    "question": "Why is brute-force subarray sum inefficient compared to sliding window?",
    "ideal_answer": "Brute force recomputes sums repeatedly, while sliding window reuses previous computations.",
    "expected_keywords": ["sliding window", "reuse"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Optimization"], "weight": 1, "max_time_sec": 120 }
  },
  {
    "id": "DSA-R-003",
    "track": "DSA",
    "topic": "Searching",
    "subtopic": "Binary Search",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "Why is binary search unsuitable for unsorted data?",
    "ideal_answer": "Binary search relies on ordering to discard half the data each step.",
    "expected_keywords": ["sorted", "discard half"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Algorithm Selection"], "weight": 2, "max_time_sec": 150 }
  },
  {
    "id": "DSA-R-004",
    "track": "DSA",
    "topic": "Sorting",
    "subtopic": "Algorithm Choice",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "Why is merge sort preferred over bubble sort for large datasets?",
    "ideal_answer": "Merge sort has O(n log n) time complexity and scales better.",
    "expected_keywords": ["n log n", "scalable"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Sorting"], "weight": 2, "max_time_sec": 150 }
  },
  {
    "id": "DSA-R-005",
    "track": "DSA",
    "topic": "Recursion",
    "subtopic": "Design",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "When would you prefer iteration over recursion?",
    "ideal_answer": "When stack space is a concern or recursion depth is large.",
    "expected_keywords": ["stack", "space"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Design Trade-off"], "weight": 2, "max_time_sec": 150 }
  },

  {
    "id": "DSA-R-006",
    "track": "DSA",
    "topic": "Stack",
    "subtopic": "Use Case",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "Why are stacks used in function call management?",
    "ideal_answer": "Because they naturally track last function calls using LIFO.",
    "expected_keywords": ["call stack", "LIFO"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["System Understanding"], "weight": 2, "max_time_sec": 150 }
  },
  {
    "id": "DSA-R-007",
    "track": "DSA",
    "topic": "Queue",
    "subtopic": "Design",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "Why is queue preferred over stack in BFS?",
    "ideal_answer": "Queue processes nodes level by level, which BFS requires.",
    "expected_keywords": ["BFS", "level"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Graph Traversal"], "weight": 2, "max_time_sec": 150 }
  },
  {
    "id": "DSA-R-008",
    "track": "DSA",
    "topic": "Linked List",
    "subtopic": "Design Trade-off",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "Why are linked lists inefficient for binary search?",
    "ideal_answer": "Because they do not support random access.",
    "expected_keywords": ["random access"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Data Structure Choice"], "weight": 2, "max_time_sec": 150 }
  },
  {
    "id": "DSA-R-009",
    "track": "DSA",
    "topic": "Trees",
    "subtopic": "BST",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "Why does a balanced BST provide faster operations?",
    "ideal_answer": "Because it keeps height minimal, ensuring O(log n) operations.",
    "expected_keywords": ["balanced", "log n"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Trees"], "weight": 2, "max_time_sec": 150 }
  },
  {
    "id": "DSA-R-010",
    "track": "DSA",
    "topic": "Graphs",
    "subtopic": "Representation",
    "difficulty": "Medium",
    "question_type": "REASONING",
    "question": "Why is adjacency list preferred over adjacency matrix for sparse graphs?",
    "ideal_answer": "Because it stores only existing edges, saving memory.",
    "expected_keywords": ["sparse", "memory"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Graphs"], "weight": 2, "max_time_sec": 150 }
  },

  {
    "id": "DSA-R-011",
    "track": "DSA",
    "topic": "Heap",
    "subtopic": "Priority Queue",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why is heap preferred over sorted array for priority queue?",
    "ideal_answer": "Heap supports faster insertion and deletion operations.",
    "expected_keywords": ["heap", "log n"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Performance"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-012",
    "track": "DSA",
    "topic": "Hashing",
    "subtopic": "Collision",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why does high load factor degrade hash table performance?",
    "ideal_answer": "Because it increases collisions, slowing down operations.",
    "expected_keywords": ["collision", "load factor"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Hashing"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-013",
    "track": "DSA",
    "topic": "Hashing",
    "subtopic": "Rehashing",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why is rehashing an expensive operation?",
    "ideal_answer": "Because all elements must be reinserted into a new table.",
    "expected_keywords": ["rehashing", "reinsertion"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Hashing"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-014",
    "track": "DSA",
    "topic": "Sorting",
    "subtopic": "Quick Sort",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why does quick sort degrade to O(nÂ²) in worst case?",
    "ideal_answer": "Because of consistently unbalanced partitions.",
    "expected_keywords": ["partition", "worst case"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Sorting"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-015",
    "track": "DSA",
    "topic": "Graphs",
    "subtopic": "Cycle Detection",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why is DFS suitable for cycle detection?",
    "ideal_answer": "Because it tracks visited nodes and recursion stack.",
    "expected_keywords": ["DFS", "cycle"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Graphs"], "weight": 3, "max_time_sec": 180 }
  },

  {
    "id": "DSA-R-016",
    "track": "DSA",
    "topic": "Complexity",
    "subtopic": "Amortized",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why is amortized analysis important in dynamic arrays?",
    "ideal_answer": "Because occasional expensive operations are spread across many cheap ones.",
    "expected_keywords": ["amortized", "dynamic array"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Complexity"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-017",
    "track": "DSA",
    "topic": "Design Thinking",
    "subtopic": "Trade-off",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why can improving time complexity increase space complexity?",
    "ideal_answer": "Because extra memory is often used to store precomputed results.",
    "expected_keywords": ["time-space tradeoff"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Design Trade-off"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-018",
    "track": "DSA",
    "topic": "Graphs",
    "subtopic": "Shortest Path",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why does BFS fail for shortest path in weighted graphs?",
    "ideal_answer": "Because BFS assumes equal edge weights.",
    "expected_keywords": ["weighted graph"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Graphs"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-019",
    "track": "DSA",
    "topic": "Trees",
    "subtopic": "AVL Tree",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why are rotations required in AVL trees?",
    "ideal_answer": "To restore balance and maintain logarithmic height.",
    "expected_keywords": ["rotation", "balance"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Trees"], "weight": 3, "max_time_sec": 180 }
  },
  {
    "id": "DSA-R-020",
    "track": "DSA",
    "topic": "System Thinking",
    "subtopic": "Scalability",
    "difficulty": "Hard",
    "question_type": "REASONING",
    "question": "Why does an algorithm that works for small input fail at scale?",
    "ideal_answer": "Because time or space complexity grows too fast with input size.",
    "expected_keywords": ["scalability", "complexity"],
    "user_explanation_required": true,
    "evaluation": { "skill_dimension": ["Scalability"], "weight": 3, "max_time_sec": 180 }
  }
]